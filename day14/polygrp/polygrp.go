package polygrp

import (
	"fmt"
)

type PolymerGroup struct {
	// the Pairs that exist in the template, e.g.
	// template : ABCD
	// Pairs    : AB:1, BC:1, CD:1
	Pairs	map[string]int

	// the processed Rules that indicate
	// originalpair -> newpair1, newpair2
	// after the insertion of the new char in between the original pair, e.g.
	// raw rule       : AB -> C
	// processed rule : AB -> AC, CB
	Rules	map[string][]string
}

func NewPolymerGroup(template string, rules []string) *PolymerGroup {
	pg := PolymerGroup{
		Pairs: parseTemplate(template),
		Rules: parseRules(rules),
	}

	return &pg
}

func (pg *PolymerGroup) Polymerize() {
	// we cant add it directly to pg.pairs because
	// it will be checked every loop
	newPairs := make(map[string]int)

	// for every pair in the template
	for pair, count := range pg.Pairs {
		// get the new pairs generated by it
		generatedPairs := pg.Rules[pair]

		// for every new pair, add it to the template
		// add it by how many original pairs we have
		for _, newPair := range generatedPairs {
			newPairs[newPair] += count
		}
	}

	// the old pairs are now gone so overwrite them with the new ones
	pg.Pairs = newPairs
}

func (pg *PolymerGroup) PolymerizeMultiple(times int) {
	for i := 0; i < times; i++ {
		pg.Polymerize()
	}
}

// for debugging
func (pg *PolymerGroup) TotalPairs() int {
	total := 0
	for pair, count := range pg.Pairs {
		fmt.Println(count, "pairs of", pair)
		total += count
	}
	return total
}

func (pg PolymerGroup) MostCommonCharCount() int {
	charMap := pairsToCharMap(pg.Pairs)

	max := 0
	for _, count := range charMap {
		if count > max {
			max = count
		}
	}

	// the first and last char always stays the same at every polymerization step
	// all other chars in between then are counted 2x
	// this is due to the way the pairs are saved
	// 
	// we can keep the first and last char so that we can increment their count
	// then we can divide all counts by 2 to get the actual count
	// but instead of that, just adding 1 then dividing by 2 achieves the same goal
	// 
	// if the max is not first or last char
	//  then it will be an even number bcs it is a char that is counted 2x
	//  so adding 1 and dividing by 2 will not change it
	// if the max it the first or last char
	//  then it will be an odd number bcs the first and last char is counted only 1x
	//  so adding 1 will change it to "counted 2x", then we divide it by 2 and get the real count
	return (max + 1) / 2
}

func (pg PolymerGroup) LeastCommonCharCount() int {
	charMap := pairsToCharMap(pg.Pairs)

	// instead of using maxint with some size
	// we just use one of the values in the map
	// this way go can determine the size of int accordingly
	var min int
	for _, count := range charMap {
		min = count
		break
	}

	for _, count := range charMap {
		if count < min {
			min = count
		}
	}

	// same deal with most common chars
	return (min + 1) / 2
}
